{"ast":null,"code":"var _jsxFileName = \"/Users/benkoehler/Desktop/Labs/tally-ai-fe/client/src/components/WidgetSystem/WidgetDisplayList.js\";\nimport React, { useState } from \"react\";\nimport WidgetContainer from \"./WidgetContainer\";\nimport { setActiveWidgets } from \"../../actions/index\";\nimport { connect } from \"react-redux\";\nimport { widgets } from \"./WidgetRegistry\";\n\nconst WidgetDisplayList = props => {\n  function getElementCenter(element) {\n    let boundingRect = element.getBoundingClientRect();\n    return {\n      x: boundingRect.left + boundingRect.width / 2,\n      y: boundingRect.top + boundingRect.height / 2\n    };\n  }\n\n  function distance(point1, point2) {\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n  }\n\n  function getClosestWidgetToMouse(mousePosition) {\n    //the closest element to the mouse we've encountered so far, at the end of the loop it will be the closest element out of them all to the mouse\n    let closestElementToMouse; //the closest distance we've encountered so far between the mouse and a widget on the screen\n\n    let closestDistanceFromMouse = 9999999; //gotta be a big screen for this loop to not find a new closest distance\n    //Loop through all the widgets on the screen and find the closest widget to the mouse position\n\n    props.activeWidgets.forEach(element => {\n      let widget = document.getElementById(element); //Lets get the distance from the mouse to this widget\n\n      let distanceFromMouseToWidget = distance(mousePosition, getElementCenter(widget));\n\n      if (distanceFromMouseToWidget < closestDistanceFromMouse) {\n        //We found a new closest! Lets update our closest variables\n        closestDistanceFromMouse = distanceFromMouseToWidget;\n        closestElementToMouse = widget;\n      }\n    });\n    return closestElementToMouse;\n  }\n\n  function DropWidget(event) {\n    //FIXME: If the user drops the widget outside of the WidgetList, this method is never called, and projections are left/dragged widgets are never added back\n    let draggedWidget = localStorage.getItem(\"dragged\"); //So we can add the widget (that was deleted while dragging) back, where the user dropped it\n    //mouse position vector\n\n    let mousePosition = {\n      x: event.screenX,\n      y: event.screenY\n    };\n    let closestWidget = getClosestWidgetToMouse(mousePosition);\n    let closestIndex = props.activeWidgets.indexOf(closestWidget.id);\n    let activeWidgetsClone = props.activeWidgets.map(item => item); //Remove projections and widgets that are of the same type as draggedWidget as well so you can't have duplicate widgets on your dashboard\n\n    activeWidgetsClone = activeWidgetsClone.filter(widget => {\n      return widget === \"projection\" || widget === draggedWidget ? false : true;\n    }); //Add back draggedWidget in its new spot\n\n    activeWidgetsClone.splice(closestIndex, 0, draggedWidget);\n    props.setActiveWidgets(activeWidgetsClone);\n  }\n\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    className: \"widgetList\",\n    onDragOver: event => {\n      event.preventDefault();\n      /* allow widgets to be droppable when being dragged over widgetList by preventingDefault*/\n      //The widget that's being dragged, we need this in storage since it's set in another file. Could change to redux state?\n\n      let draggedWidget = localStorage.getItem(\"dragged\"); //So we can delete the widget while its being dragged\n      //mouse position vector\n\n      let mousePosition = {\n        x: event.pageX,\n        y: event.pageY\n      };\n      let closestWidget = getClosestWidgetToMouse(mousePosition);\n      let closestIndex = props.activeWidgets.indexOf(closestWidget.id); //If the widgets array doesn't already contain a projection widget in closestIndex, add one and remove any out of position ones. \n      //Otherwise, even though the mouse location changed, the projection is still correct and there is no need to re-render\n\n      if (!(props.activeWidgets[closestIndex] === \"projection\")) {\n        let activeWidgetsClone = props.activeWidgets.map(item => item); //remove out-of-position projections\n\n        activeWidgetsClone = activeWidgetsClone.filter(widget => {\n          return widget === \"projection\" || widget === draggedWidget ? false : true;\n        }); //Add new projection in correct position\n\n        activeWidgetsClone.splice(closestIndex, 0, \"projection\");\n        props.setActiveWidgets(activeWidgetsClone);\n      }\n    },\n    onDragLeave: e => DropWidget(e),\n    onDrop: e => DropWidget(e),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73\n    },\n    __self: this\n  }, props.activeWidgets.map(widgetName => {\n    return React.createElement(WidgetContainer, {\n      widgetName: widgetName,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 113\n      },\n      __self: this\n    }) //WidgetContainer will render the correct widget based on widgetName\n    ;\n  })));\n};\n\nconst mapStateToProps = state => ({\n  activeWidgets: state.activeWidgets\n});\n\nexport default connect(mapStateToProps, {\n  setActiveWidgets\n})(WidgetDisplayList);","map":{"version":3,"sources":["/Users/benkoehler/Desktop/Labs/tally-ai-fe/client/src/components/WidgetSystem/WidgetDisplayList.js"],"names":["React","useState","WidgetContainer","setActiveWidgets","connect","widgets","WidgetDisplayList","props","getElementCenter","element","boundingRect","getBoundingClientRect","x","left","width","y","top","height","distance","point1","point2","Math","sqrt","pow","getClosestWidgetToMouse","mousePosition","closestElementToMouse","closestDistanceFromMouse","activeWidgets","forEach","widget","document","getElementById","distanceFromMouseToWidget","DropWidget","event","draggedWidget","localStorage","getItem","screenX","screenY","closestWidget","closestIndex","indexOf","id","activeWidgetsClone","map","item","filter","splice","preventDefault","pageX","pageY","e","widgetName","mapStateToProps","state"],"mappings":"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","sourcesContent":["import React, { useState } from \"react\";\n\nimport WidgetContainer from \"./WidgetContainer\";\nimport { setActiveWidgets } from \"../../actions/index\";\nimport { connect } from \"react-redux\";\n\nimport { widgets } from \"./WidgetRegistry\";\n\nconst WidgetDisplayList = (props) => {\n\n    function getElementCenter(element) {\n\n        let boundingRect = element.getBoundingClientRect();\n\n        return { x: boundingRect.left + boundingRect.width / 2, y: boundingRect.top + boundingRect.height / 2 }\n\n    }\n\n    function distance(point1, point2) {\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n    }\n\n    function getClosestWidgetToMouse(mousePosition) {\n\n        //the closest element to the mouse we've encountered so far, at the end of the loop it will be the closest element out of them all to the mouse\n        let closestElementToMouse;\n\n        //the closest distance we've encountered so far between the mouse and a widget on the screen\n        let closestDistanceFromMouse = 9999999;//gotta be a big screen for this loop to not find a new closest distance\n        //Loop through all the widgets on the screen and find the closest widget to the mouse position\n        props.activeWidgets.forEach(element => {\n            \n            let widget = document.getElementById(element);\n            \n            //Lets get the distance from the mouse to this widget\n            let distanceFromMouseToWidget = distance(mousePosition, getElementCenter(widget));\n\n            if (distanceFromMouseToWidget < closestDistanceFromMouse) {\n                //We found a new closest! Lets update our closest variables\n                closestDistanceFromMouse = distanceFromMouseToWidget;\n                closestElementToMouse = widget;\n            }\n        });\n\n        return closestElementToMouse;\n\n    }\n\n    function DropWidget(event) {\n\n        //FIXME: If the user drops the widget outside of the WidgetList, this method is never called, and projections are left/dragged widgets are never added back\n\n        let draggedWidget = localStorage.getItem(\"dragged\");//So we can add the widget (that was deleted while dragging) back, where the user dropped it\n\n        //mouse position vector\n        let mousePosition = { x: event.screenX, y: event.screenY }\n\n        let closestWidget = getClosestWidgetToMouse(mousePosition);\n\n        let closestIndex = props.activeWidgets.indexOf(closestWidget.id);\n\n        let activeWidgetsClone = props.activeWidgets.map((item) => item);\n        //Remove projections and widgets that are of the same type as draggedWidget as well so you can't have duplicate widgets on your dashboard\n        activeWidgetsClone = activeWidgetsClone.filter((widget) => { return widget === \"projection\" || widget === draggedWidget ? false : true; })\n        //Add back draggedWidget in its new spot\n        activeWidgetsClone.splice(closestIndex, 0, draggedWidget)\n        props.setActiveWidgets(activeWidgetsClone);\n    }\n\n    return (\n        <div>\n            {/* <h4>Widgets</h4> */}\n            <div className=\"widgetList\" onDragOver={(event) => {\n\n                event.preventDefault(); /* allow widgets to be droppable when being dragged over widgetList by preventingDefault*/\n\n                //The widget that's being dragged, we need this in storage since it's set in another file. Could change to redux state?\n                let draggedWidget = localStorage.getItem(\"dragged\");//So we can delete the widget while its being dragged\n\n                //mouse position vector\n                let mousePosition = { x: event.pageX, y: event.pageY }\n\n                let closestWidget = getClosestWidgetToMouse(mousePosition);\n\n                let closestIndex = props.activeWidgets.indexOf(closestWidget.id);\n\n                //If the widgets array doesn't already contain a projection widget in closestIndex, add one and remove any out of position ones. \n                //Otherwise, even though the mouse location changed, the projection is still correct and there is no need to re-render\n                if (!(props.activeWidgets[closestIndex] === \"projection\")) {\n\n                    let activeWidgetsClone = props.activeWidgets.map((item) => item);\n\n                    //remove out-of-position projections\n                    activeWidgetsClone = activeWidgetsClone.filter((widget) => { return widget === \"projection\" || widget === draggedWidget ? false : true; })\n                    //Add new projection in correct position\n                    activeWidgetsClone.splice(closestIndex, 0, \"projection\")\n\n                    props.setActiveWidgets(activeWidgetsClone);\n\n                }\n\n            }\n            } onDragLeave={\n                (e) => DropWidget(e)\n            } onDrop= {\n                (e) => DropWidget(e)\n            }>\n\n                {/* Render Active Widgets */}\n                {\n                    props.activeWidgets.map((widgetName) => {\n                        return (\n                            <WidgetContainer widgetName={widgetName} />//WidgetContainer will render the correct widget based on widgetName\n                        )\n                    })\n                }\n\n            </div>\n        </div>\n    );\n}\n\nconst mapStateToProps = state => ({\n    activeWidgets: state.activeWidgets\n  });\n  \n  export default connect(mapStateToProps, { setActiveWidgets })(WidgetDisplayList);\n"]},"metadata":{},"sourceType":"module"}